;; Snippet definitions start at a line with the following format (;; is for comment, ignore)
;; ; <snippet name> <return label> <args>
;; And will end at a line with a lone semicolon ;
;; ;
;; That's why comments in this file start with two ;; to prevent the parser from getting confused.

;; Available only for variables:
;; %1R:   for raw name (as in the source code)
;; %1E:   for the encoded name (as in the assembly file)
;; %1L:   for length of the array (1 for non-array variables)

;; Available for both variables and registers:
;; %1S:   for size ('byte', 'word' etc.)
;; %1C:   for clause (same as %1S [%1E] if variable, otherwise %1E)
;; %1N:   for size as number of bytes
;; %1U:   for size of a unit in bytes
;; %1a-d: for corresponding register of unit size

;; the number after the % sign is the index of the argument (zero indexed)
;; %e followed by a suffix/tail will give the information of an element of self
;; eg. element of *3 is 3, element of [4]*[2]5 is *[2]5

; _header void
extern printf
extern sprintf
extern malloc
extern exit
global main
;

; _data void
segment .data
_p: db `%u\n`, 0
_c: db 0, 0
_ln: db 0, 10, 0
_fmt_udstr: db `%llu`, 0
_str: times 3 dq 0
_p_str: db `%s`, 0
_p_strln: db `%s\n`, 0
;

; _exit void
xor rcx, rcx
push rbp
call exit
;

; _udneg $s s
mov %0a, %0C
neg %0a
;

; _udinvert $s s
mov %0a, %0C
not %0a
;

; _udadd $s s s
mov %0a, %0C
add %1a, %1C
;

; _udsub $s s s
mov %0a, %0C
sub %1a, %1C
;

; _udmul $s s s
mov %0a, %0C
mul %1C
;

; _udtruediv $s s s
xor rdx, rdx
mov %0a, %0C
div %1C
;

; _udmod $s s s
xor rdx, rdx
mov %0a, %0C
div %1C
mov %0a, %0d
;

; _udstr *3 s
mov rcx, _str
mov rdx, _fmt_udstr
xor r8, r8
mov %0r8, %0C
push rbp
call sprintf
pop rbp
mov rax, _str
;

; _pdstr *3 6
mov rax, %0C
;

; _adstr *3 6
mov rax, %0E
;

; _pdderef $e 6
mov rax, %0C
mov %ea, %eS [%0a]
;

; _pdsetat void 6 e
mov rcx, %0C
mov %1a, %1C
mov %1S [rcx], %1a
;

; _udref *$s s
mov rax, %0E
;

; _pdref *$s s
mov rax, %0E
;

; _adref *$s s
mov rax, %0E
;

; _adgetitem $e e
mov %1a, %1C
mov %0a, %0S [eax * %0U + %0E]
;

; _adsetitem void s 6 e
xor rbx, rbx
mov %1b, %1C
mov %2a,  %2C
mov %2S [rbx * %0U + %0E], %2a
;

; str *3 s
%0.__str__()
;

; printnum void 6
xor rdx, rdx
xor %0d, %0C
xor rax, rax
mov rcx, _p
push rbp
call printf
pop rbp
;

; print void s
%0.__str__()
mov rdx, rax
mov rcx, _p_str
push rbp
call printf
pop rbp
;

; println void s
%0.__str__()
mov rdx, rax
mov rcx, _p_strln
push rbp
call printf
pop rbp
;

; _ctrl_while_precond void 6
.L%0R:
;

; _ctrl_while_postcond void 3 6
%0.__bool__()
jz .L%1R_end
;

; _ctrl_while_end void 6
jmp .L%0R
.L%0R_end:
;
