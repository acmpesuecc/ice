;; Available for only variables:
;; %1r:   for raw name (as in the source code)
;; %1e:   for the encoded name (as in the assembly file)
;; %1l:   for length of the array (1 for non-array variables)

;; Available for both variables and registers:
;; %1s:   for size ('byte', 'word' etc.)
;; %1c:   for clause (short for %1s [%1e])
;; %1n:   for size as number of bytes
;; %1a-d: for corresponding register of unit size

;; the number after the % sign is the index of the argument (zero indexed)
;; %e followed by a suffix/tail will give the information of an element of self
;; eg. element of *3 is 3, element of [4]*[2]5 is *[2]5

; _header void
extern printf
extern malloc
global main
;

; _data void
segment .data
_p: db `%u\n`, 0
_c: db 0, 0
_ln: db 0, 10, 0
;

; _udprint void s
mov  rsi, %0e
mov  rdi, _name_%0r
xor  rax, rax
call printf
;

; _udneg $s s
mov %sa, %0c
neg %sa
;

; _udadd $s s s
mov %sa, %0
add %sa, %1
;

; _udsub $s s s
mov %sa, %0c
sub %sa, %1c
;

; _udmul $s s s
mov %sa, %0c
mul %1c
;

; 6_dderef $e 8
mov rax, qword [%0e]
mov %ea, %es [%0]
;

; _udref *$s s
mov rax, %0e
;

; _adgetitem $e e
mov %1a, %1
mov %0a, %0s [eax * %0n + %0e]
;

; _adsetitem void 
mov %1b, %1
mov %0s [%1b * %0n + %0e], %0a
;

; printnum void
xor eax, eax
xor %1a, %1
push eax
push _p
call _printf
add esp, 8
;

; print void
mov bl, byte [(%1l*%1n) + (%1e-1)]
mov byte [(%1l*%1n) + (%1e-1)], 0
push %1e
call _printf
add esp, 4
mov byte [(%1l*%1n) + (%1e-1)], bl

mov byte [_c], bl
push _c
call _printf
add esp, 4
;

; println void
mov bl, byte [(%1l*%1n) + (%1e-1)]
mov byte [(%1l*%1n) + (%1e-1)], 0
push %1e
call _printf
add esp, 4
mov byte [(%1l*%1n) + (%1e-1)], bl

mov byte [_ln], bl
push _ln
call _printf
add esp, 4
;
